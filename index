<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vokabel-Extraktions-Tool - Universal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        .step-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        .step {
            display: flex;
            align-items: center;
            color: #6c757d;
            font-weight: 500;
            margin: 0 15px;
        }
        .step.active {
            color: #007bff;
        }
        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-weight: bold;
        }
        .step.active .step-number {
            background: #007bff;
            color: white;
        }
        .main-content {
            padding: 30px;
            min-height: 400px;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .file-upload {
            border: 3px dashed #007bff;
            border-radius: 15px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
        }
        .file-upload:hover, .file-upload.dragover {
            border-color: #0056b3;
            background: #e3f2fd;
        }
        .file-upload h3 {
            color: #007bff;
            margin-bottom: 10px;
        }
        .file-upload p {
            color: #6c757d;
            margin-bottom: 20px;
        }
        .file-input {
            display: none;
        }
        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin: 5px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }
        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }
        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
        }
        .card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            background: linear-gradient(90deg, #007bff, #0056b3);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        .page-selection {
            margin: 20px 0;
        }
        .page-selection label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }
        .page-selection input[type="radio"] {
            margin-right: 10px;
        }
        .page-selection input[type="text"] {
            margin-left: 20px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: none;
        }
        .words-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .words-table th,
        .words-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle;
        }
        .words-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        .words-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        .word-input,
        .word-textarea,
        .dropdown {
            width: 100%;
            padding-top: 8px !important;
            padding-bottom: 8px !important;
            padding-left: 8px;
            padding-right: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.4;
            vertical-align: middle;
        }
        .word-textarea {
            resize: vertical;
            min-height: 60px;
            padding-top: 10px !important;
        }
        .dropdown {
            height: auto;
            min-height: 40px;
        }
        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        .word-count {
            background: #007bff;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-weight: bold;
            margin-left: 10px;
        }
        .ai-prompt-container {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .ai-prompt {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .ai-response {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }
        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }
        .hidden {
            display: none !important;
        }
        .text-center {
            text-align: center;
        }
        .mt-3 {
            margin-top: 20px;
        }
        .debug-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .debug-content {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .footer {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ecf0f1;
            padding: 40px 20px 20px;
            margin-top: 40px;
        }
        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        .footer-section h4 {
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .footer-section p {
            font-size: 0.9em;
            line-height: 1.6;
            color: #bdc3c7;
        }
        .footer-bottom {
            border-top: 1px solid #34495e;
            padding-top: 20px;
            text-align: center;
            color: #95a5a6;
            font-size: 0.85em;
        }
        .target-group-section {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
        }
        .target-group-section h4 {
            color: #1976d2;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }
        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .input-group small {
            display: block;
            margin-top: 5px;
            color: #6c757d;
            font-size: 0.9em;
        }
        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .preset-btn {
            padding: 8px 16px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        .preset-btn:hover {
            background: #e9ecef;
            border-color: #007bff;
        }
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            .main-content {
                padding: 20px;
            }
            .step-indicator {
                flex-wrap: wrap;
                gap: 10px;
            }
            .step {
                margin: 5px;
            }
            .words-table {
                font-size: 12px;
            }
            .word-input,
            .word-textarea,
            .dropdown {
                font-size: 12px;
                padding: 6px;
            }
            .footer-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Vokabel-Extraktions-Tool</h1>
            <p>Extrahieren Sie Vokabeln aus Dokumenten und erstellen Sie personalisierte Lernlisten</p>
        </div>
        <div class="step-indicator">
            <div class="step active">
                <div class="step-number">1</div>
                <span>Datei hochladen</span>
            </div>
            <div class="step">
                <div class="step-number">2</div>
                <span>W√∂rter extrahieren</span>
            </div>
            <div class="step">
                <div class="step-number">3</div>
                <span class="tooltip">Liste bearbeiten<span class="tooltiptext">Hier k√∂nnen Sie extrahierte W√∂rter bearbeiten, hinzuf√ºgen oder entfernen.</span></span>
            </div>
            <div class="step">
                <div class="step-number">4</div>
                <span class="tooltip">KI-Verbesserung<span class="tooltiptext">Generieren Sie einen Prompt, um Ihre Vokabelliste von einer KI erweitern zu lassen.</span></span>
            </div>
            <div class="step">
                <div class="step-number">5</div>
                <span class="tooltip">KI-Import<span class="tooltiptext">F√ºgen Sie die Antwort Ihrer KI hier ein, um die verbesserte Liste zu importieren.</span></span>
            </div>
            <div class="step">
                <div class="step-number">6</div>
                <span class="tooltip">Final Review<span class="tooltiptext">√úberpr√ºfen Sie die finalen Vokabeln vor dem Export.</span></span>
            </div>
            <div class="step">
                <div class="step-number">7</div>
                <span>Export</span>
            </div>
        </div>
        <div class="main-content">
            <div id="upload-section" class="section active">
                <div class="card">
                    <h3>üìÅ Datei hochladen</h3>
                    <p>Laden Sie eine PDF-, Word- oder Textdatei hoch, um Vokabeln zu extrahieren. (Max. Dateigr√∂√üe: 10 MB)</p>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <div style="font-size: 3em; margin-bottom: 20px;">üìÑ</div>
                        <h3>Datei hier ablegen oder klicken zum Ausw√§hlen</h3>
                        <p>Unterst√ºtzte Formate: PDF, DOCX, TXT</p>
                        <input type="file" id="fileInput" class="file-input" accept=".pdf,.docx,.txt">
                    </div>
                    <div id="file-info" class="hidden">
                        <p><strong>Ausgew√§hlte Datei:</strong> <span id="file-name"></span></p>
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="extract-section" class="section">
                <div class="card">
                    <h3>üîç W√∂rter extrahieren</h3>
                    <p>W√§hlen Sie die Seiten aus, von denen Sie Vokabeln extrahieren m√∂chten.</p>
                    <div class="page-selection">
                        <label>
                            <input type="radio" name="pageSelection" value="all" checked>
                            Alle Seiten (Gesamt: <span id="total-pdf-pages">N/A</span>)
                        </label>
                        <label>
                            <input type="radio" name="pageSelection" value="specific">
                            Bestimmte Seiten
                            <input type="text" id="pageRange" placeholder="z.B. 1-5, 8, 10-12" aria-label="Seitenauswahl">
                        </label>
                    </div>
                    <div class="text-center mt-3">
                        <button id="backToUploadBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="extractBtn" class="btn">W√∂rter extrahieren</button>
                    </div>
                </div>
            </div>
            <div id="edit-list-section" class="section">
                <div class="card">
                    <h3>‚úèÔ∏è Vokabelliste bearbeiten</h3>
                    <p>Bearbeiten Sie die extrahierten W√∂rter und f√ºgen Sie weitere hinzu.</p>
                    
                    <!-- Zielgruppen-Konfiguration -->
                    <div class="target-group-section">
                        <h4>üéì Zielgruppe festlegen</h4>
                        <div class="input-group">
                            <label for="targetGroup">Berufsfeld / Zielgruppe:</label>
                            <input type="text" id="targetGroup" placeholder="z.B. B√§ckerei-Fachverkauf, Bau-Berufe, Gastronomie...">
                            <small>Geben Sie das Berufsfeld oder die Zielgruppe an, f√ºr die die Vokabeln aufbereitet werden sollen.</small>
                            <div class="preset-buttons">
                                <button class="preset-btn" onclick="setPreset('B√§ckerei-Fachverkauf')">ü•ñ B√§ckerei</button>
                                <button class="preset-btn" onclick="setPreset('Bau-Berufe (Maurer, Zimmerer, Trockenbauer)')">üèóÔ∏è Bau</button>
                                <button class="preset-btn" onclick="setPreset('Gastronomie und Hotellerie')">üçΩÔ∏è Gastro</button>
                                <button class="preset-btn" onclick="setPreset('Einzelhandel')">üõí Handel</button>
                                <button class="preset-btn" onclick="setPreset('Pflege und Gesundheit')">üíä Pflege</button>
                                <button class="preset-btn" onclick="setPreset('KFZ-Technik')">üöó KFZ</button>
                            </div>
                        </div>
                        <div class="input-group">
                            <label for="contextExamples">Kontext-Beispiele (optional):</label>
                            <textarea id="contextExamples" placeholder="z.B. Baustelle, Werkzeuge, Materialien, Arbeitssicherheit..."></textarea>
                            <small>Geben Sie typische Begriffe oder Themen an, die in den Beispiels√§tzen vorkommen sollen.</small>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <span>Gefundene W√∂rter:</span>
                        <span id="word-count" class="word-count">0</span>
                        <button id="addWordBtn" class="btn btn-secondary" style="margin-left: 20px;">+ Wort hinzuf√ºgen</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="words-table" role="grid" aria-live="polite" aria-relevant="all">
                            <thead>
                                <tr>
                                    <th scope="col">Wort</th>
                                    <th scope="col">Wortart</th>
                                    <th scope="col">Begriffserkl√§rung</th>
                                    <th scope="col">Beispielsatz</th>
                                    <th scope="col">Aktion</th>
                                </tr>
                            </thead>
                            <tbody id="words-tbody"></tbody>
                        </table>
                    </div>
                    <div class="text-center mt-3">
                        <label for="targetLanguage">Zielsprache f√ºr √úbersetzung:</label>
                        <input type="text" id="targetLanguage" placeholder="z.B. Englisch, Franz√∂sisch..." style="margin: 0 10px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                        <button id="backToExtractBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="proceedToAIExportBtn" class="btn">Weiter zur KI-Verbesserung</button>
                    </div>
                </div>
            </div>
            <div id="export-section" class="section">
                <div class="card">
                    <h3>ü§ñ KI-Verbesserung</h3>
                    <p>Kopieren Sie den folgenden Prompt und f√ºgen Sie ihn in ChatGPT oder Claude ein.</p>
                    <div class="ai-prompt-container">
                        <pre id="ai-prompt" class="ai-prompt">Prompt wird generiert...</pre>
                    </div>
                    <div class="text-center mt-3">
                        <button id="backToEditBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="copyPromptBtn" class="btn">üìã Prompt kopieren</button>
                        <button id="proceedToAIImportBtn" class="btn">Weiter zu KI-Import</button>
                    </div>
                </div>
            </div>
            <div id="import-section" class="section">
                <div class="card">
                    <h3>üì• KI-Antwort importieren</h3>
                    <p>F√ºgen Sie die Antwort der KI hier ein:</p>
                    <textarea id="ai-response" class="ai-response" placeholder="F√ºgen Sie hier die KI-Antwort ein..."></textarea>
                    <div class="text-center mt-3">
                        <button id="backToAIExportBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="importBtn" class="btn">KI-Antwort importieren</button>
                        <button onclick="showDebugInfo()" class="btn btn-secondary">üîç Debug-Info anzeigen</button>
                    </div>
                </div>
                <div id="debug-section" class="debug-section hidden">
                    <h4>üîç Debug-Informationen</h4>
                    <p>Erkannte Vokabel-Bl√∂cke: <span id="debug-count">0</span></p>
                    <div id="debug-content" class="debug-content"></div>
                </div>
            </div>
            <div id="final-review-section" class="section">
                <div class="card">
                    <h3>üëÅÔ∏è Finale √úberpr√ºfung</h3>
                    <p>√úberpr√ºfen Sie die finalen Vokabeln vor dem Export.</p>
                    <div style="margin-bottom: 20px;">
                        <span>Finale W√∂rter:</span>
                        <span id="final-word-count" class="word-count">0</span>
                        <button id="addFinalWordBtn" class="btn btn-secondary" style="margin-left: 20px;">+ Wort hinzuf√ºgen</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="words-table" role="grid" aria-live="polite" aria-relevant="all">
                            <thead>
                                <tr>
                                    <th>Wort</th>
                                    <th>Wortart</th>
                                    <th>Begriffserkl√§rung</th>
                                    <th>Beispielsatz</th>
                                    <th>Aktion</th>
                                </tr>
                            </thead>
                            <tbody id="final-words-tbody"></tbody>
                        </table>
                    </div>
                    <div class="text-center mt-3">
                        <button id="backToAIImportBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="proceedToFinalExportBtn" class="btn">Weiter zum Export</button>
                    </div>
                </div>
            </div>
            <div id="final-export-section" class="section">
                <div class="card">
                    <h3>üì§ Export</h3>
                    <p>Exportieren Sie Ihre Vokabelliste als PDF oder CSV.</p>
                    <div class="text-center mt-3">
                        <button id="backToFinalReviewBtn" class="btn btn-secondary">Zur√ºck</button>
                        <button id="exportPdfBtn" class="btn btn-success">üìÑ Als PDF exportieren</button>
                        <button id="exportCsvBtn" class="btn btn-success">üìä Als CSV exportieren</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h4>üìã √úber dieses Tool</h4>
                <p>Das Vokabel-Extraktions-Tool wurde speziell f√ºr ausl√§ndische Berufssch√ºler entwickelt, um den Spracherwerb zu unterst√ºtzen.</p>
            </div>
            <div class="footer-section">
                <h4>‚öñÔ∏è Haftungsausschluss</h4>
                <p>Die Nutzung dieses Tools erfolgt auf eigene Verantwortung. Alle Inhalte werden ohne Gew√§hr bereitgestellt. F√ºr die Richtigkeit, Vollst√§ndigkeit und Aktualit√§t der generierten Inhalte wird keine Haftung √ºbernommen.</p>
            </div>
            <div class="footer-section">
                <h4>üîí Datenschutzhinweis</h4>
                <p>Dieses Tool verarbeitet alle Daten ausschlie√ülich lokal in Ihrem Browser. Es werden keine Daten an externe Server √ºbertragen oder gespeichert. Ihre hochgeladenen Dokumente und erstellten Vokabellisten bleiben privat.</p>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 F. Wenisch | Alle Rechte vorbehalten</p>
            <p style="margin-top: 5px; font-size: 0.8em;">Vokabel-Extraktions-Tool f√ºr Berufsschulen</p>
        </div>
    </footer>
    <script>
        let extractedWords = [];
        let finalWords = [];
        let rawDocumentContent = null;
        let rawPdfDocument = null;
        let documentType = '';
        let totalPages = 0;
        let selectedPages = 'all';
        let pageRangeText = '';
        let targetLanguageName = '';
        let targetGroupName = '';
        let contextExamplesText = '';
        const MAX_FILE_SIZE_MB = 10;
        const COMMON_GERMAN_WORDS = new Set([
            "der", "die", "das", "und", "ist", "in", "es", "ein", "eine", "einer", "eines",
            "nicht", "mit", "als", "f√ºr", "auf", "an", "sich", "von", "zu", "dem", "den",
            "oder", "auch", "aber", "aus", "durch", "nach", "vor", "um", "bei", "zum", "zur",
            "wie", "so", "noch", "schon", "nur", "sehr", "mehr", "kein", "keine", "er", "sie", "ihr",
            "wir", "ich", "du", "was", "wer", "wo", "wann", "warum", "wie", "hat", "haben", "sein",
            "werden", "kann", "k√∂nnen", "muss", "m√ºssen", "soll", "sollen", "will", "wollen",
            "hatte", "waren", "wurde", "w√ºrde", "dies", "diese", "dieser", "dieses", "alle", "jeder",
            "man", "viel", "viele", "gut", "besser", "schlecht", "gern", "gerne", "immer", "nie", "oft",
            "selten", "bald", "heute", "morgen", "gestern", "hier", "dort", "da", "neben", "unter", "√ºber",
            "zwischen", "hinter", "durch", "gegen", "ohne", "statt", "trotz", "w√§hrend", "wegen",
            "seit", "bis", "dann", "wenn", "obwohl", "damit", "sowie", "jedoch", "denn", "weil",
            "dass", "ob", "als", "seit", "nachdem", "bevor", "w√§hrend", "solange", "sobald", "kaum",
            "weder", "noch", "entweder", "oder"
        ]);
        const WORD_TYPES = [
            'Nomen', 'Verb', 'Adjektiv', 'Adverb', 'Pronomen',
            'Pr√§position', 'Interjektion', 'Konjunktion', 'Partikel', 'Numerale', 'Andere'
        ];
        const MAX_WORD_LENGTH = 80;
        const MAX_DEFINITION_LENGTH = 80;
        const MAX_EXAMPLE_LENGTH = 80;
        const MAX_TRANSLATION_LENGTH = 80;
        const MIN_WORD_CHARS = 2;
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
        });
        
        function setPreset(presetName) {
            const targetGroupInput = document.getElementById('targetGroup');
            if (targetGroupInput) {
                targetGroupInput.value = presetName;
                targetGroupName = presetName;
            }
        }
        
        function sanitizeInput(input, type = 'text') {
            if (typeof input !== 'string') return '';
            let sanitized = input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            if (type === 'word') {
                sanitized = sanitized.replace(/[^a-zA-Z√§√∂√º√Ñ√ñ√ú√ü\s\(\)\[\]\{\}\-'\.,;:]/g, '');
                sanitized = sanitized.substring(0, MAX_WORD_LENGTH);
            } else if (type === 'definition' || type === 'example') {
                sanitized = sanitized.substring(0, MAX_DEFINITION_LENGTH);
            } else if (type === 'translation') {
                sanitized = sanitized.substring(0, MAX_TRANSLATION_LENGTH);
            } else if (type === 'pageRange') {
                sanitized = sanitized.replace(/[^0-9,\-\s]/g, '');
            }
            return sanitized.trim();
        }
        
        function parseMarkdownResponse(rawResponse) {
            const parsedWords = [];
            
            let cleanedResponse = rawResponse.replace(/```markdown\s*/gi, '').replace(/```\s*/g, '');
            
            const blocks = cleanedResponse.split(/\n\s*\n+/);
            
            for (let block of blocks) {
                if (!block.trim()) continue;
                
                const wordEntry = {
                    word: '',
                    wordType: '',
                    definition: '',
                    example: '',
                    translation: ''
                };
                
                block = block.replace(/^\d+\.\s*/, '');
                
                const lines = block.split('\n').map(line => line.trim()).filter(line => line);
                
                for (let line of lines) {
                    line = line.replace(/\*\*/g, '').replace(/\*/g, '');
                    
                    if (line.match(/^Wort:/i)) {
                        wordEntry.word = line.replace(/^Wort:\s*/i, '').trim();
                    }
                    else if (line.match(/^Wortart:/i)) {
                        wordEntry.wordType = line.replace(/^Wortart:\s*/i, '').trim();
                    }
                    else if (line.match(/^Begriffserkl√§rung:/i)) {
                        wordEntry.definition = line.replace(/^Begriffserkl√§rung:\s*/i, '').trim();
                    }
                    else if (line.match(/^Beispielsatz:/i)) {
                        wordEntry.example = line.replace(/^Beispielsatz:\s*/i, '').trim();
                    }
                    else if (line.match(/^√úbersetzung(\s*\([^)]+\))?:/i)) {
                        wordEntry.translation = line.replace(/^√úbersetzung(\s*\([^)]+\))?:\s*/i, '').trim();
                    }
                }
                
                if (wordEntry.word) {
                    parsedWords.push({
                        word: sanitizeInput(wordEntry.word, 'word'),
                        wordType: sanitizeInput(wordEntry.wordType, 'text'),
                        definition: sanitizeInput(wordEntry.definition, 'definition'),
                        example: sanitizeInput(wordEntry.example, 'example'),
                        translation: sanitizeInput(wordEntry.translation, 'translation')
                    });
                }
            }
            
            return parsedWords;
        }
        
        function initializeEventListeners() {
            const elements = {
                fileInput: document.getElementById('fileInput'),
                extractBtn: document.getElementById('extractBtn'),
                addWordBtn: document.getElementById('addWordBtn'),
                addFinalWordBtn: document.getElementById('addFinalWordBtn'),
                backToUploadBtn: document.getElementById('backToUploadBtn'),
                backToExtractBtn: document.getElementById('backToExtractBtn'),
                backToEditBtn: document.getElementById('backToEditBtn'),
                backToAIExportBtn: document.getElementById('backToAIExportBtn'),
                backToFinalReviewBtn: document.getElementById('backToFinalReviewBtn'),
                proceedToAIExportBtn: document.getElementById('proceedToAIExportBtn'),
                copyPromptBtn: document.getElementById('copyPromptBtn'),
                proceedToAIImportBtn: document.getElementById('proceedToAIImportBtn'),
                importBtn: document.getElementById('importBtn'),
                proceedToFinalExportBtn: document.getElementById('proceedToFinalExportBtn'),
                exportPdfBtn: document.getElementById('exportPdfBtn'),
                exportCsvBtn: document.getElementById('exportCsvBtn'),
                targetLanguage: document.getElementById('targetLanguage'),
                targetGroup: document.getElementById('targetGroup'),
                contextExamples: document.getElementById('contextExamples'),
                pageRange: document.getElementById('pageRange'),
                fileUploadArea: document.querySelector('.file-upload')
            };
            
            if (elements.fileInput) elements.fileInput.addEventListener('change', handleFileUpload);
            if (elements.extractBtn) elements.extractBtn.addEventListener('click', extractWords);
            if (elements.addWordBtn) elements.addWordBtn.addEventListener('click', () => addNewWord('words-tbody', extractedWords, 'word-count'));
            if (elements.addFinalWordBtn) elements.addFinalWordBtn.addEventListener('click', () => addNewWord('final-words-tbody', finalWords, 'final-word-count'));
            if (elements.backToUploadBtn) elements.backToUploadBtn.addEventListener('click', () => { showSection('upload-section'); updateStepIndicator(1); });
            if (elements.backToExtractBtn) elements.backToExtractBtn.addEventListener('click', () => { showSection('extract-section'); updateStepIndicator(2); });
            if (elements.backToEditBtn) elements.backToEditBtn.addEventListener('click', () => { showSection('edit-list-section'); updateStepIndicator(3); });
            if (elements.backToAIExportBtn) elements.backToAIExportBtn.addEventListener('click', () => { showSection('export-section'); updateStepIndicator(4); });
            if (elements.backToFinalReviewBtn) elements.backToFinalReviewBtn.addEventListener('click', () => { showSection('final-review-section'); updateStepIndicator(6); });
            
            if (elements.proceedToAIExportBtn) {
                elements.proceedToAIExportBtn.addEventListener('click', async () => {
                    showSection('export-section');
                    updateStepIndicator(4);
                    targetLanguageName = elements.targetLanguage ? sanitizeInput(elements.targetLanguage.value.trim(), 'text') : '';
                    targetGroupName = elements.targetGroup ? sanitizeInput(elements.targetGroup.value.trim(), 'text') : '';
                    contextExamplesText = elements.contextExamples ? sanitizeInput(elements.contextExamples.value.trim(), 'text') : '';
                    const promptElement = document.getElementById('ai-prompt');
                    if (promptElement) promptElement.textContent = await generateAIPrompt();
                });
            }
            
            if (elements.copyPromptBtn) elements.copyPromptBtn.addEventListener('click', copyPrompt);
            if (elements.proceedToAIImportBtn) elements.proceedToAIImportBtn.addEventListener('click', () => { showSection('import-section'); updateStepIndicator(5); });
            if (elements.importBtn) elements.importBtn.addEventListener('click', importFromAI);
            if (elements.proceedToFinalExportBtn) elements.proceedToFinalExportBtn.addEventListener('click', () => { showSection('final-export-section'); updateStepIndicator(7); });
            if (elements.exportPdfBtn) elements.exportPdfBtn.addEventListener('click', exportToPDF);
            if (elements.exportCsvBtn) elements.exportCsvBtn.addEventListener('click', exportToCSV);
            
            if (elements.targetLanguage) {
                elements.targetLanguage.addEventListener('input', async (e) => {
                    targetLanguageName = sanitizeInput(e.target.value.trim(), 'text');
                });
            }
            
            if (elements.targetGroup) {
                elements.targetGroup.addEventListener('input', (e) => {
                    targetGroupName = sanitizeInput(e.target.value.trim(), 'text');
                });
            }
            
            if (elements.contextExamples) {
                elements.contextExamples.addEventListener('input', (e) => {
                    contextExamplesText = sanitizeInput(e.target.value.trim(), 'text');
                });
            }
            
            if (elements.fileUploadArea) {
                elements.fileUploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    elements.fileUploadArea.classList.add('dragover');
                });
                elements.fileUploadArea.addEventListener('dragleave', () => {
                    elements.fileUploadArea.classList.remove('dragover');
                });
                elements.fileUploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    elements.fileUploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) handleFileUpload({ target: { files } });
                });
            }
            
            const pageSelectionRadios = document.querySelectorAll('input[name="pageSelection"]');
            if (pageSelectionRadios.length > 0) {
                pageSelectionRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        if (elements.pageRange) {
                            elements.pageRange.style.display = e.target.value === 'specific' ? 'block' : 'none';
                        }
                        selectedPages = e.target.value;
                    });
                });
            }
            
            if (elements.pageRange) {
                elements.pageRange.addEventListener('input', (e) => {
                    pageRangeText = e.target.value.trim();
                });
            }
        }
        
        function showSection(sectionId) {
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));
            const targetSection = document.getElementById(sectionId);
            if (targetSection) {
                targetSection.classList.add('active');
                const firstInteractiveElement = targetSection.querySelector('button, input, textarea, select');
                if (firstInteractiveElement) firstInteractiveElement.focus();
            }
        }
        
        function updateStepIndicator(stepNumber) {
            const steps = document.querySelectorAll('.step');
            steps.forEach((step, index) => {
                if (index + 1 === stepNumber) {
                    step.classList.add('active');
                } else {
                    step.classList.remove('active');
                }
            });
        }
        
        function showError(message) {
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.prepend(errorDiv);
                setTimeout(() => errorDiv.remove(), 7000);
            }
        }
        
        function showSuccess(message) {
            document.querySelectorAll('.error, .success').forEach(el => el.remove());
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.prepend(successDiv);
                setTimeout(() => successDiv.remove(), 5000);
            }
        }
        
        function showDebugInfo() {
            const aiResponseElement = document.getElementById('ai-response');
            if (!aiResponseElement) {
                showError('Debug-Funktion nicht verf√ºgbar.');
                return;
            }
            const aiResponse = aiResponseElement.value.trim();
            if (!aiResponse) {
                showError('Bitte f√ºgen Sie zuerst die KI-Antwort ein.');
                return;
            }
            const debugSection = document.getElementById('debug-section');
            const debugContent = document.getElementById('debug-content');
            const debugCount = document.getElementById('debug-count');
            if (!debugSection || !debugContent || !debugCount) {
                showError('Debug-Elemente nicht gefunden.');
                return;
            }
            const parsedDebugWords = parseMarkdownResponse(aiResponse);
            let debugInfo = `=== KI-ANTWORT DEBUGGING (MARKDOWN-FORMAT) ===\n\n`;
            debugInfo += `Rohe Antwort-L√§nge: ${aiResponse.length} Zeichen\n\n`;
            debugInfo += `Erste 500 Zeichen:\n"${aiResponse.substring(0, 500)}"\n\n`;
            debugInfo += `Erkannte Vokabel-Bl√∂cke: ${parsedDebugWords.length}\n\n`;
            parsedDebugWords.slice(0, 10).forEach((wordObj, index) => {
                debugInfo += `--- Block ${index + 1} ---\n`;
                debugInfo += `Wort: "${wordObj.word || 'N/A'}"\n`;
                debugInfo += `Wortart: "${wordObj.wordType || 'N/A'}"\n`;
                debugInfo += `Begriffserkl√§rung: "${wordObj.definition || 'N/A'}"\n`;
                debugInfo += `Beispielsatz: "${wordObj.example || 'N/A'}"\n`;
                debugInfo += `√úbersetzung: "${wordObj.translation || 'N/A'}"\n\n`;
            });
            if (parsedDebugWords.length > 10) {
                debugInfo += `... und ${parsedDebugWords.length - 10} weitere Bl√∂cke.\n`;
            }
            debugCount.textContent = parsedDebugWords.length;
            debugContent.textContent = debugInfo;
            debugSection.classList.remove('hidden');
        }
        
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                showError(`Die Datei ist zu gro√ü. Maximale Gr√∂√üe ist ${MAX_FILE_SIZE_MB} MB.`);
                return;
            }
            const fileNameElement = document.getElementById('file-name');
            const fileInfoElement = document.getElementById('file-info');
            const progressFill = document.getElementById('progress-fill');
            const totalPdfPagesElement = document.getElementById('total-pdf-pages');
            if (!fileNameElement || !fileInfoElement || !progressFill || !totalPdfPagesElement) {
                showError('UI-Elemente fehlen.');
                return;
            }
            fileNameElement.textContent = file.name;
            fileInfoElement.classList.remove('hidden');
            progressFill.style.width = '0%';
            rawDocumentContent = null;
            rawPdfDocument = null;
            documentType = '';
            totalPages = 0;
            totalPdfPagesElement.textContent = 'N/A';
            try {
                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                    documentType = 'pdf';
                    if (typeof pdfjsLib !== 'undefined') {
                        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
                        const arrayBuffer = await file.arrayBuffer();
                        rawPdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        totalPages = rawPdfDocument.numPages;
                        totalPdfPagesElement.textContent = totalPages;
                        showSuccess(`PDF "${file.name}" geladen. Seiten: ${totalPages}`);
                    } else {
                        throw new Error('PDF.js nicht geladen.');
                    }
                } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                    documentType = 'docx';
                    if (typeof mammoth !== 'undefined') {
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        rawDocumentContent = result.value;
                        showSuccess(`Word-Datei "${file.name}" geladen.`);
                    } else {
                        throw new Error('Mammoth.js nicht geladen.');
                    }
                } else if (file.type === 'text/plain') {
                    documentType = 'txt';
                    rawDocumentContent = await file.text();
                    showSuccess(`Textdatei "${file.name}" geladen.`);
                } else {
                    showError('Nicht unterst√ºtztes Dateiformat.');
                    return;
                }
                progressFill.style.width = '100%';
                showSection('extract-section');
                updateStepIndicator(2);
            } catch (error) {
                showError('Fehler beim Laden: ' + (error.message || 'Unbekannter Fehler.'));
                progressFill.style.width = '0%';
                fileInfoElement.classList.add('hidden');
            }
        }
        
        function parsePageRange(pageRangeInput, totalPages) {
            const sanitizedInput = sanitizeInput(pageRangeInput, 'pageRange');
            const pages = new Set();
            if (!sanitizedInput) {
                showError('Ung√ºltige Seitenauswahl.');
                return null;
            }
            const parts = sanitizedInput.split(',').map(s => s.trim());
            for (const part of parts) {
                if (!part) continue;
                if (part.includes('-')) {
                    const rangeParts = part.split('-').map(Number);
                    if (rangeParts.length !== 2 || isNaN(rangeParts[0]) || isNaN(rangeParts[1]) || rangeParts[0] > rangeParts[1]) {
                        showError(`Ung√ºltiger Bereich "${part}".`);
                        return null;
                    }
                    let [start, end] = rangeParts;
                    start = Math.max(1, start);
                    end = Math.min(totalPages, end);
                    for (let i = start; i <= end; i++) pages.add(i);
                } else {
                    const pageNum = Number(part);
                    if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) {
                        showError(`Ung√ºltige Seitenzahl "${part}".`);
                        return null;
                    }
                    pages.add(pageNum);
                }
            }
            if (pages.size === 0) {
                showError('Keine g√ºltigen Seiten.');
                return null;
            }
            return Array.from(pages).sort((a, b) => a - b);
        }
        
        async function extractTextFromPdf(pdfDocument, pageSelectionType, pageRangeString) {
            let fullText = '';
            let pagesToExtract = [];
            if (pageSelectionType === 'all') {
                for (let i = 1; i <= pdfDocument.numPages; i++) pagesToExtract.push(i);
            } else {
                const parsedPages = parsePageRange(pageRangeString, pdfDocument.numPages);
                if (parsedPages === null) throw new Error("Ung√ºltige Seitenauswahl.");
                pagesToExtract = parsedPages;
            }
            if (pagesToExtract.length === 0) throw new Error("Keine Seiten zum Extrahieren.");
            for (const pageNum of pagesToExtract) {
                try {
                    const page = await pdfDocument.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).filter(Boolean).join(' ').replace(/\s+/g, ' ').trim();
                    fullText += pageText + '\n\n';
                } catch (pageError) {
                    showError(`Warnung: Seite ${pageNum} nicht extrahiert.`);
                }
            }
            return fullText;
        }
        
        async function extractWords() {
            let textToProcess = '';
            extractedWords = [];
            try {
                if (documentType === 'pdf') {
                    if (!rawPdfDocument) {
                        showError('Kein PDF geladen.');
                        return;
                    }
                    textToProcess = await extractTextFromPdf(rawPdfDocument, selectedPages, pageRangeText);
                } else if (documentType === 'docx' || documentType === 'txt') {
                    if (!rawDocumentContent) {
                        showError('Kein Dokument geladen.');
                        return;
                    }
                    textToProcess = rawDocumentContent;
                } else {
                    showError('Bitte laden Sie zuerst eine Datei hoch.');
                    return;
                }
                const words = textToProcess.match(/\b[a-zA-Z√§√∂√º√Ñ√ñ√ú√ü-]{2,}\b/g) || [];
                const uniqueWords = [...new Set(words.map(word => word.toLowerCase()))];
                extractedWords = uniqueWords
                    .filter(word =>
                        word.length >= MIN_WORD_CHARS &&
                        !COMMON_GERMAN_WORDS.has(word) &&
                        /^[a-zA-Z√§√∂√º√Ñ√ñ√ú√ü-]+$/.test(word)
                    )
                    .map(word => ({
                        word: word,
                        wordType: 'Nomen',
                        definition: '',
                        example: ''
                    }));
                renderWordsTable('words-tbody', extractedWords, 'word-count');
                showSection('edit-list-section');
                updateStepIndicator(3);
                showSuccess(`${extractedWords.length} W√∂rter extrahiert.`);
            } catch (error) {
                showError('Fehler beim Extrahieren: ' + (error.message || 'Unbekannter Fehler.'));
            }
        }
        
        function renderWordsTable(tbodyId, wordsArray, countId) {
            const tbody = document.getElementById(tbodyId);
            const countElement = document.getElementById(countId);
            if (!tbody) {
                showError(`Tabelle nicht gefunden (${tbodyId}).`);
                return;
            }
            const fragment = document.createDocumentFragment();
            const tableHeadersRow = tbody.previousElementSibling.querySelector('thead tr');
            let existingTranslationHeader = tableHeadersRow.querySelector('th[data-col="translation"]');
            if (tbodyId !== 'final-words-tbody' && existingTranslationHeader) {
                existingTranslationHeader.remove();
            } else if (tbodyId === 'final-words-tbody' && !existingTranslationHeader) {
                const translationHeader = document.createElement('th');
                translationHeader.scope = 'col';
                translationHeader.textContent = '√úbersetzung';
                translationHeader.setAttribute('data-col', 'translation');
                tableHeadersRow.insertBefore(translationHeader, tableHeadersRow.children[4]);
            }
            wordsArray.forEach((wordObj, index) => {
                const row = document.createElement('tr');
                const wordCell = document.createElement('td');
                const wordInput = document.createElement('input');
                wordInput.type = 'text';
                wordInput.className = 'word-input';
                wordInput.value = wordObj.word;
                wordInput.setAttribute('maxlength', MAX_WORD_LENGTH);
                wordInput.addEventListener('input', (e) => {
                    wordObj.word = sanitizeInput(e.target.value, 'word');
                    e.target.value = wordObj.word;
                });
                wordCell.appendChild(wordInput);
                row.appendChild(wordCell);
                const wordTypeCell = document.createElement('td');
                const wordTypeSelect = document.createElement('select');
                wordTypeSelect.className = 'dropdown';
                WORD_TYPES.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    if (wordObj.wordType === type) option.selected = true;
                    wordTypeSelect.appendChild(option);
                });
                wordTypeSelect.addEventListener('change', (e) => wordObj.wordType = e.target.value);
                wordTypeCell.appendChild(wordTypeSelect);
                row.appendChild(wordTypeCell);
                const definitionCell = document.createElement('td');
                const definitionTextarea = document.createElement('textarea');
                definitionTextarea.className = 'word-textarea';
                definitionTextarea.value = wordObj.definition;
                definitionTextarea.placeholder = 'Kurze Erkl√§rung';
                definitionTextarea.setAttribute('maxlength', MAX_DEFINITION_LENGTH);
                definitionTextarea.addEventListener('input', (e) => {
                    wordObj.definition = sanitizeInput(e.target.value, 'definition');
                    e.target.value = wordObj.definition;
                });
                definitionCell.appendChild(definitionTextarea);
                row.appendChild(definitionCell);
                const exampleCell = document.createElement('td');
                const exampleTextarea = document.createElement('textarea');
                exampleTextarea.className = 'word-textarea';
                exampleTextarea.value = wordObj.example;
                exampleTextarea.placeholder = 'Kurzer Beispielsatz';
                exampleTextarea.setAttribute('maxlength', MAX_EXAMPLE_LENGTH);
                exampleTextarea.addEventListener('input', (e) => {
                    wordObj.example = sanitizeInput(e.target.value, 'example');
                    e.target.value = wordObj.example;
                });
                exampleCell.appendChild(exampleTextarea);
                row.appendChild(exampleCell);
                if (tbodyId === 'final-words-tbody') {
                    const translationCell = document.createElement('td');
                    const translationTextarea = document.createElement('textarea');
                    translationTextarea.className = 'word-textarea';
                    translationTextarea.value = wordObj.translation || '';
                    translationTextarea.placeholder = '√úbersetzung';
                    translationTextarea.setAttribute('maxlength', MAX_TRANSLATION_LENGTH);
                    translationTextarea.addEventListener('input', (e) => {
                        wordObj.translation = sanitizeInput(e.target.value, 'translation');
                        e.target.value = wordObj.translation;
                    });
                    translationCell.appendChild(translationTextarea);
                    row.appendChild(translationCell);
                }
                const actionCell = document.createElement('td');
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-btn';
                deleteButton.textContent = 'L√∂schen';
                deleteButton.addEventListener('click', () => {
                    const rowIndex = Array.from(tbody.children).indexOf(row);
                    if (rowIndex > -1) {
                        wordsArray.splice(rowIndex, 1);
                        renderWordsTable(tbodyId, wordsArray, countId);
                        showSuccess('Wort gel√∂scht.');
                    }
                });
                actionCell.appendChild(deleteButton);
                row.appendChild(actionCell);
                fragment.appendChild(row);
            });
            tbody.innerHTML = '';
            tbody.appendChild(fragment);
            if (countElement) countElement.textContent = wordsArray.length;
        }
        
        function addNewWord(tbodyId, wordsArray, countId) {
            wordsArray.push({
                word: '',
                wordType: 'Nomen',
                definition: '',
                example: '',
                translation: ''
            });
            renderWordsTable(tbodyId, wordsArray, countId);
            const tbody = document.getElementById(tbodyId);
            if (tbody && tbody.lastElementChild) {
                const wordInput = tbody.lastElementChild.querySelector('.word-input');
                if (wordInput) wordInput.focus();
            }
            showSuccess('Neues Wort hinzugef√ºgt.');
        }
        
        async function generateAIPrompt() {
            if (extractedWords.length === 0) {
                return "Bitte extrahieren Sie zuerst W√∂rter. Der Prompt wird dann hier generiert.";
            }
            
            const vocabularyList = extractedWords.map(word => {
                let entry = `- ${sanitizeInput(word.word, 'word')}`;
                if (word.wordType && word.wordType !== 'Andere' && word.wordType !== '') {
                    entry += ` (${sanitizeInput(word.wordType, 'text')})`;
                }
                if (word.definition) {
                    entry += ` - ${sanitizeInput(word.definition, 'definition')}`;
                }
                if (word.example) {
                    entry += ` | Beispiel: ${sanitizeInput(word.example, 'example')}`;
                }
                return entry;
            }).join('\n');
            
            const targetGroupText = targetGroupName ? targetGroupName : 'Berufssch√ºler';
            const contextText = contextExamplesText ? `\n\nKONTEXT-HINWEISE:\nBitte verwende in den Beispiels√§tzen Bez√ºge zu folgenden Themen: ${contextExamplesText}` : '';
            
            let prompt = `Du bist ein Sprachlehrer f√ºr ausl√§ndische ${targetGroupText}.

WICHTIG - AUSGABEFORMAT:
Antworte AUSSCHLIESSLICH im MARKDOWN-Format!
Nutze KEINE Code-Bl√∂cke (keine \`\`\`markdown), sondern reines Markdown!

KRITISCH - LIES ZUERST:
Die unten aufgef√ºhrten W√∂rter stammen aus einem hochgeladenen Dokument.
Bearbeite AUSSCHLIESSLICH diese vorgegebenen W√∂rter - erfinde KEINE eigenen!
Auch wenn W√∂rter nicht zum Bereich ${targetGroupText} passen, m√ºssen sie bearbeitet werden.
Ersetze oder √ºberspringe NIEMALS ein Wort aus der Liste!

AUFGABE:
Erstelle eine alphabetisch sortierte Vokabelliste (ignoriere Artikel bei der Sortierung).
Die Sch√ºler ben√∂tigen kurze, klare und pr√§zise Informationen - keine langen Texte!
${contextText}

MARKDOWN-FORMAT (EXAKT SO):
F√ºr jedes Wort aus der Liste:

1.
**Wort:** [grammatikalische Form]
**Wortart:** [Wortart]
**Begriffserkl√§rung:** [max. 80 Zeichen]
**Beispielsatz:** [max. 80 Zeichen]`;

            if (targetLanguageName) {
                prompt += `
**√úbersetzung (${sanitizeInput(targetLanguageName, 'text')}):** [max. 80 Zeichen]`;
            }

            prompt += `

2.
**Wort:** [grammatikalische Form]
**Wortart:** [Wortart]
**Begriffserkl√§rung:** [max. 80 Zeichen]
**Beispielsatz:** [max. 80 Zeichen]`;

            if (targetLanguageName) {
                prompt += `
**√úbersetzung (${sanitizeInput(targetLanguageName, 'text')}):** [max. 80 Zeichen]`;
            }

            prompt += `

GRAMMATIKALISCHE FORMEN:
‚Ä¢ Nomen: Artikel + Singular + Plural
  Beispiel: "das Werkzeug, die Werkzeuge" oder "die Aufgabe, die Aufgaben"
‚Ä¢ Verben: Infinitiv, 3. Person Pr√§sens, Pr√§teritum, Partizip II
  Beispiel: "arbeiten, arbeitet, arbeitete, gearbeitet"
‚Ä¢ Adjektive: Positiv, Komparativ, Superlativ
  Beispiel: "wichtig, wichtiger, am wichtigsten"

REGELN F√úR BEGRIFFSERKL√ÑRUNGEN UND BEISPIELE:
‚úì Maximal 80 Zeichen - das ist essentiell!
‚úì Einfache W√∂rter verwenden (A1-B1 Niveau)
‚úì Kurze Haupts√§tze, keine Nebens√§tze
‚úì Aktiv statt Passiv
‚úì Ein Gedanke pro Satz
‚úì Bezug zum Bereich ${targetGroupText} wo passend
‚úì Bei anderen W√∂rtern: Allgemeiner, leicht verst√§ndlicher Kontext

NOCHMAL WICHTIG - MARKDOWN-REGELN:
- Verwende Nummerierung: 1., 2., 3. etc.
- Verwende **fett** nur f√ºr die Feldnamen (Wort:, Wortart:, etc.)
- Jedes Feld auf einer eigenen Zeile
- Eine Leerzeile zwischen den Worteintr√§gen
- KEINE Code-Bl√∂cke (\`\`\`markdown)
- Bearbeite JEDES Wort aus der untenstehenden Liste
- Keine W√∂rter auslassen, ersetzen oder hinzuf√ºgen
- Keine Einleitung, kein Kommentar, keine Erkl√§rung
- Starte sofort mit "1."

HIER SIND DIE W√ñRTER AUS DEM DOKUMENT:
${vocabularyList}

Beginne JETZT SOFORT mit der Nummerierung "1." - keine Einleitung!
Antworte NUR in reinem Markdown (keine \`\`\`-Bl√∂cke)!`;

            return prompt;
        }
        
        async function copyPrompt() {
            const promptElement = document.getElementById('ai-prompt');
            if (promptElement && promptElement.textContent) {
                try {
                    await navigator.clipboard.writeText(promptElement.textContent);
                    showSuccess('Prompt kopiert! F√ºgen Sie ihn in ChatGPT oder Claude ein.');
                } catch (err) {
                    showError('Fehler beim Kopieren: ' + err);
                }
            } else {
                showError('Kein Prompt zum Kopieren.');
            }
        }
        
        async function importFromAI() {
            const aiResponseElement = document.getElementById('ai-response');
            if (!aiResponseElement || !aiResponseElement.value.trim()) {
                showError('Bitte f√ºgen Sie die KI-Antwort ein.');
                return;
            }
            try {
                finalWords = parseMarkdownResponse(aiResponseElement.value.trim());
                if (finalWords.length > 0) {
                    renderWordsTable('final-words-tbody', finalWords, 'final-word-count');
                    showSection('final-review-section');
                    updateStepIndicator(6);
                    showSuccess(`${finalWords.length} Vokabeln importiert und bereit zur √úberpr√ºfung!`);
                } else {
                    showError('Keine Vokabeln gefunden. Bitte √ºberpr√ºfen Sie das Markdown-Format.');
                }
            } catch (error) {
                showError('Fehler beim Import: ' + (error.message || 'Unbekannter Fehler.'));
            }
        }
        
        async function exportToPDF() {
            if (finalWords.length === 0) {
                showError('Keine Vokabeln zum Export.');
                return;
            }
            try {
                if (typeof window.jspdf === 'undefined' || !window.jspdf.jsPDF) {
                    throw new Error('jsPDF nicht geladen.');
                }
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l', 'mm', 'a4');
                const margin = 10;
                const pageHeight = doc.internal.pageSize.height;
                const defaultLineHeight = 5;
                const cellPadding = 2;
                const headerHeight = 10;
                const titleHeight = 20;
                const colWidths = {
                    wort: 50,
                    wortart: 25,
                    definition: 70,
                    example: 70,
                    translation: targetLanguageName ? 40 : 0,
                    eigene: 40
                };
                
                doc.setFontSize(16);
                const pdfTitle = targetGroupName ? `Vokabelliste ${targetGroupName}` : 'Vokabelliste';
                doc.text(pdfTitle, margin, titleHeight);
                
                let y = titleHeight + 15;
                const drawTableHeader = () => {
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    let x = margin;
                    doc.rect(x, y, colWidths.wort, headerHeight);
                    doc.text("Wort/Grammatik", x + cellPadding, y + headerHeight / 2 + 1);
                    x += colWidths.wort;
                    doc.rect(x, y, colWidths.wortart, headerHeight);
                    doc.text("Wortart", x + cellPadding, y + headerHeight / 2 + 1);
                    x += colWidths.wortart;
                    doc.rect(x, y, colWidths.definition, headerHeight);
                    doc.text("Erkl√§rung", x + cellPadding, y + headerHeight / 2 + 1);
                    x += colWidths.definition;
                    doc.rect(x, y, colWidths.example, headerHeight);
                    doc.text("Beispiel", x + cellPadding, y + headerHeight / 2 + 1);
                    x += colWidths.example;
                    if (targetLanguageName) {
                        doc.rect(x, y, colWidths.translation, headerHeight);
                        doc.text(`${targetLanguageName}`, x + cellPadding, y + headerHeight / 2 + 1);
                        x += colWidths.translation;
                    }
                    doc.rect(x, y, colWidths.eigene, headerHeight);
                    doc.text("Eigene", x + cellPadding, y + headerHeight / 2 + 1);
                    y += headerHeight;
                    doc.setFont(undefined, 'normal');
                };
                drawTableHeader();
                for (const wordObj of finalWords) {
                    const safeWord = wordObj.word || '';
                    const safeWordType = wordObj.wordType || '';
                    const safeDefinition = wordObj.definition || '';
                    const safeExample = wordObj.example || '';
                    const safeTranslation = wordObj.translation || '';
                    const wordLines = doc.splitTextToSize(safeWord, colWidths.wort - 2 * cellPadding);
                    const wordTypeLines = doc.splitTextToSize(safeWordType, colWidths.wortart - 2 * cellPadding);
                    const defLines = doc.splitTextToSize(safeDefinition, colWidths.definition - 2 * cellPadding);
                    const exampleLines = doc.splitTextToSize(safeExample, colWidths.example - 2 * cellPadding);
                    const translationLines = targetLanguageName ? doc.splitTextToSize(safeTranslation, colWidths.translation - 2 * cellPadding) : [''];
                    const maxLines = Math.max(
                        wordLines.length,
                        wordTypeLines.length,
                        defLines.length,
                        exampleLines.length,
                        translationLines.length,
                        1
                    );
                    const rowHeight = maxLines * defaultLineHeight + 2 * cellPadding;
                    if (y + rowHeight > pageHeight - margin) {
                        doc.addPage();
                        y = margin;
                        drawTableHeader();
                    }
                    let x = margin;
                    doc.rect(x, y, colWidths.wort, rowHeight);
                    doc.text(wordLines, x + cellPadding, y + cellPadding + defaultLineHeight - 1);
                    x += colWidths.wort;
                    doc.rect(x, y, colWidths.wortart, rowHeight);
                    doc.text(wordTypeLines, x + cellPadding, y + cellPadding + defaultLineHeight - 1);
                    x += colWidths.wortart;
                    doc.rect(x, y, colWidths.definition, rowHeight);
                    doc.text(defLines, x + cellPadding, y + cellPadding + defaultLineHeight - 1);
                    x += colWidths.definition;
                    doc.rect(x, y, colWidths.example, rowHeight);
                    doc.text(exampleLines, x + cellPadding, y + cellPadding + defaultLineHeight - 1);
                    x += colWidths.example;
                    if (targetLanguageName) {
                        doc.rect(x, y, colWidths.translation, rowHeight);
                        doc.text(translationLines, x + cellPadding, y + cellPadding + defaultLineHeight - 1);
                        x += colWidths.translation;
                    }
                    doc.rect(x, y, colWidths.eigene, rowHeight);
                    y += rowHeight;
                }
                doc.output('dataurlnewwindow');
                showSuccess('PDF erstellt!');
            } catch (error) {
                showError('PDF-Export Fehler: ' + (error.message || 'Unbekannter Fehler.'));
            }
        }
        
        async function exportToCSV() {
            showError('CSV Export noch nicht implementiert.');
        }
    </script>
</body>
</html>
